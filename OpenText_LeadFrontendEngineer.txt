OpenText_LeadFrontendEngineer

Round 1:
Explain Microfrontend Architecture? Authentication, Authorization, How SSO works, Routing, Communication between MFEs, Reusable Components


	<MFE HOST -> MFEAdoptors, auth sdk <npm package>, <Module> routing, timeout, permission> : 
	
	MFE -> register -> json (mfe, tag, qa - js bundles, prod - etc)
	MFE - entittlements -> 
	
	MFE1 -> MFE2 (customEvents()), AppState (MFE1: {} , MFE2: {} ), SharedModule (Manages State for all the MFEs)
	
	Design System/UI Library: Resuable components; Accordiaon, Cards, Button, etc;
	
	
	App -> Serve to multiple clients/company (100), own config, feature, images, branding, color;
	
	Configuration -> for each clients - client1 {  } ;
	
	domain -> subdomain.com/ path-param/
	
	SSO -> url -> sso login (user, pwd);
	
	register; clientId, SAML protocaol, redirecturl -> 
	
	<Roles, Permission>;
	
	XSS, CSRF, -> sanitizing (); same-origin; csp; <frame src, frame>;
	
	web1 -> 
	
	
	AWS EKS Ingress, Egress configuration;
	
console.log("begins");

setTimeout(() => {  console.log("setTimeout 1"); 

Promise.resolve().then(() => {    console.log("promise 1");  });}, 0
);

new Promise(function (resolve, reject) {  
console.log("promise 2"); 
 
setTimeout(function () {   
console.log("setTimeout 2");    
  resolve("resolve 1");  
}, 0);

}).then((res) => { 
console.log("dot then 1");
  setTimeout(() => { 
   console.log(res); 
 }, 0);
});

begins 


	
	
	
console.log("begins");
setTimeout(() => {
  console.log("setTimeout 1");
  Promise.resolve().then(() => { 
    console.log("promise 1");
  });
}, 0);

new Promise(function (resolve, reject) {
  console.log("promise 2");
  setTimeout(function () { //2
    console.log("setTimeout 2");
    resolve("resolve 1");
  }, 0);
}).then((res) => {
  console.log("dot then 1");
  setTimeout(() => { // 3
    console.log(res);
  }, 0);
});

begins
promise 2
setTimeout 1
promise 1
setTimeout 2
dot then 1
resolve 1


// result;
"begins"
"promise 2"
"setTimeout 1"
"promise 1"
"setTimeout 2"
"dot then 1"
"resolve 1"


arr=[1,3,0,3,0,2,6,0]; // [1,3,3,2,6,0,0,0]; 

// startPt, endPoint

let start = 0, end = arr.length - 1;

while(start <= end){
  if(arr[start] === 0 && arr[end] !== 0){
    const temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
    start++;
    end--;
  } else if(arr[start] !== 0 && arr[end] === 0){
    end--;
  } 
}

console.log(arr);


arr=[1,3,0,3,0,2,6,0]; // [1,3,3,2,6,0,0,0]; 

// startPt, endPoint

let start = 0, end = arr.length - 1;

while(start <= end){
  if(arr[start] === 0 && arr[end] !== 0){
    const temp = arr[start];
    arr[start] = arr[end];
    arr[end] = temp;
    start++;
    end--;
  } else if(arr[start] !== 0 && arr[end] === 0){
    end--;
  } 
}

console.log(arr);


function deepClone(obj){
  const clonedObj = { };

  for([key, value] of obj){
    if(typeof value === 'number' || typeof value === 'string' || typeof value === 'bool'){
     clonedObj[key] = value;
    } else if(Array.isArray(value)){
      clonedObj[key] = [];
      for(let i = 0; i < value.length; i++){
        clonedObj[key][i] = deepClone(value[i]);
      }
    } else if(typeof value === 'object'){
      const objClone = { };
      for(const [key, val] of value){
        objClone[key] = deepClone(val);
      }
      clonedObj[key] = objClone;
    } else if(value instanceof Date){
      clonedObj[key] = Date.toString(value);
    }
  }


  return clonedObj;
}



function debounce(fn, delay){
  let isRun = false;

  return function(args){
      if(isRun){
        fn(args);
        isRun = false;
      }
      setTimeout(() => {
        isRun = true;
      }, delay);
  }

}

export default function useDebounce(fn, delay){

  return debounce(fn, delay);

}

import React, { useRef } from 'react';

import useDebounce from './useDebounce.js'; 

export function App(props) {
  const inputRef = useRef('');

  const handleOnChange = (value) => {
    console.log(value);
  }

  const debouncedFn = useDebounce(handleOnChange, 300);

  const fn = (val) => {
    debouncedFn(val);
  }

  return (
    <div className='App'>
      <h1>Hello React.</h1>
      <input ref={inputRef} onChange={ e => fn(e.target.value)} />
    </div>
  );
}

// Log to console
console.log('Hello console')




function deepClone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(deepClone);
  }

  const clone = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      clone[key] = deepClone(obj[key]);
    }
  }
  return clone;
}

const originalObject = {
  id: 1,
  config: {
    setting1: true,
    arrayData: [1, 2, { nested: "value" }],
  },
};

const clonedObject = deepClone(originalObject);

console.log(clonedObject.id); // 1
console.log(clonedObject.config.setting1); // true
console.log(clonedObject.config.arrayData[2].nested); // value

